// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Addons.Animator;
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  [Flags()]
  public enum AnimatorStateType : byte {
    None,
    FromState,
    CurrentState,
    ToState,
  }
  public enum EKCCCollisionSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCIgnoreSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCProcessorSource : byte {
    None = 0,
    Modifier = 1,
    StaticCollider = 2,
    EntityCollider = 3,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Jump = 1 << 0,
    Dodge = 1 << 1,
    LightAttack = 1 << 2,
    HeavyAttack = 1 << 3,
    Parry = 1 << 4,
    Special = 1 << 5,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public readonly Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 2;
    public readonly Int32 Length {
      get {
        return 2;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet2 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0] & 0x3UL);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if ((p[0] & 0x3UL) != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13619;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public readonly Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 32; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public readonly Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        result += Maths.CountSetBits(p[2]);
        result += Maths.CountSetBits(p[3]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        if (p[2] != 0) return true;
        if (p[3] != 0) return true;
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public readonly Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 64; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 64; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public readonly Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 8; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 8; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BlendTreeWeights {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<FP> Values;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 14387;
        hash = hash * 31 + Values.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Values = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BlendTreeWeights*)ptr;
        QList.Serialize(&p->Values, serializer, Statics.SerializeFP);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 112;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(96)]
    public FPVector2 LeftStickDirection;
    [FieldOffset(48)]
    public Button Jump;
    [FieldOffset(8)]
    public QBoolean JumpHeld;
    [FieldOffset(24)]
    public Button Dodge;
    [FieldOffset(0)]
    public QBoolean DodgeHeld;
    [FieldOffset(60)]
    public Button LightAttack;
    [FieldOffset(12)]
    public QBoolean LightAttackHeld;
    [FieldOffset(36)]
    public Button HeavyAttack;
    [FieldOffset(4)]
    public QBoolean HeavyAttackHeld;
    [FieldOffset(72)]
    public Button Parry;
    [FieldOffset(16)]
    public QBoolean ParryHeld;
    [FieldOffset(84)]
    public Button Special;
    [FieldOffset(20)]
    public QBoolean SpecialHeld;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + LeftStickDirection.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + JumpHeld.GetHashCode();
        hash = hash * 31 + Dodge.GetHashCode();
        hash = hash * 31 + DodgeHeld.GetHashCode();
        hash = hash * 31 + LightAttack.GetHashCode();
        hash = hash * 31 + LightAttackHeld.GetHashCode();
        hash = hash * 31 + HeavyAttack.GetHashCode();
        hash = hash * 31 + HeavyAttackHeld.GetHashCode();
        hash = hash * 31 + Parry.GetHashCode();
        hash = hash * 31 + ParryHeld.GetHashCode();
        hash = hash * 31 + Special.GetHashCode();
        hash = hash * 31 + SpecialHeld.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 2;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Jump: return Jump.IsDown;
        case InputButtons.Dodge: return Dodge.IsDown;
        case InputButtons.LightAttack: return LightAttack.IsDown;
        case InputButtons.HeavyAttack: return HeavyAttack.IsDown;
        case InputButtons.Parry: return Parry.IsDown;
        case InputButtons.Special: return Special.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Jump: return Jump.WasPressed;
        case InputButtons.Dodge: return Dodge.WasPressed;
        case InputButtons.LightAttack: return LightAttack.WasPressed;
        case InputButtons.HeavyAttack: return HeavyAttack.WasPressed;
        case InputButtons.Parry: return Parry.WasPressed;
        case InputButtons.Special: return Special.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        QBoolean.Serialize(&p->DodgeHeld, serializer);
        QBoolean.Serialize(&p->HeavyAttackHeld, serializer);
        QBoolean.Serialize(&p->JumpHeld, serializer);
        QBoolean.Serialize(&p->LightAttackHeld, serializer);
        QBoolean.Serialize(&p->ParryHeld, serializer);
        QBoolean.Serialize(&p->SpecialHeld, serializer);
        Button.Serialize(&p->Dodge, serializer);
        Button.Serialize(&p->HeavyAttack, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->LightAttack, serializer);
        Button.Serialize(&p->Parry, serializer);
        Button.Serialize(&p->Special, serializer);
        FPVector2.Serialize(&p->LeftStickDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCCollision {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCCollisionSource Source;
    [FieldOffset(16)]
    public EntityRef Reference;
    [FieldOffset(8)]
    public AssetRef Processor;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7523;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCCollision*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCData {
    public const Int32 SIZE = 528;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public QBoolean IsActive;
    [FieldOffset(72)]
    public FP LookPitch;
    [FieldOffset(80)]
    public FP LookYaw;
    [FieldOffset(120)]
    public FPVector3 BasePosition;
    [FieldOffset(144)]
    public FPVector3 DesiredPosition;
    [FieldOffset(504)]
    public FPVector3 TargetPosition;
    [FieldOffset(40)]
    public FP DeltaTime;
    [FieldOffset(360)]
    public FPVector3 InputDirection;
    [FieldOffset(384)]
    public FPVector3 JumpImpulse;
    [FieldOffset(264)]
    public FPVector3 Gravity;
    [FieldOffset(88)]
    public FP MaxGroundAngle;
    [FieldOffset(104)]
    public FP MaxWallAngle;
    [FieldOffset(96)]
    public FP MaxHangAngle;
    [FieldOffset(240)]
    public FPVector3 ExternalImpulse;
    [FieldOffset(216)]
    public FPVector3 ExternalForce;
    [FieldOffset(192)]
    public FPVector3 ExternalDelta;
    [FieldOffset(64)]
    public FP KinematicSpeed;
    [FieldOffset(432)]
    public FPVector3 KinematicTangent;
    [FieldOffset(408)]
    public FPVector3 KinematicDirection;
    [FieldOffset(456)]
    public FPVector3 KinematicVelocity;
    [FieldOffset(168)]
    public FPVector3 DynamicVelocity;
    [FieldOffset(112)]
    public FP RealSpeed;
    [FieldOffset(480)]
    public FPVector3 RealVelocity;
    [FieldOffset(0)]
    public QBoolean HasJumped;
    [FieldOffset(4)]
    public QBoolean HasTeleported;
    [FieldOffset(12)]
    public QBoolean IsGrounded;
    [FieldOffset(24)]
    public QBoolean WasGrounded;
    [FieldOffset(20)]
    public QBoolean IsSteppingUp;
    [FieldOffset(32)]
    public QBoolean WasSteppingUp;
    [FieldOffset(16)]
    public QBoolean IsSnappingToGround;
    [FieldOffset(28)]
    public QBoolean WasSnappingToGround;
    [FieldOffset(288)]
    public FPVector3 GroundNormal;
    [FieldOffset(336)]
    public FPVector3 GroundTangent;
    [FieldOffset(312)]
    public FPVector3 GroundPosition;
    [FieldOffset(56)]
    public FP GroundDistance;
    [FieldOffset(48)]
    public FP GroundAngle;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6067;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + LookPitch.GetHashCode();
        hash = hash * 31 + LookYaw.GetHashCode();
        hash = hash * 31 + BasePosition.GetHashCode();
        hash = hash * 31 + DesiredPosition.GetHashCode();
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + InputDirection.GetHashCode();
        hash = hash * 31 + JumpImpulse.GetHashCode();
        hash = hash * 31 + Gravity.GetHashCode();
        hash = hash * 31 + MaxGroundAngle.GetHashCode();
        hash = hash * 31 + MaxWallAngle.GetHashCode();
        hash = hash * 31 + MaxHangAngle.GetHashCode();
        hash = hash * 31 + ExternalImpulse.GetHashCode();
        hash = hash * 31 + ExternalForce.GetHashCode();
        hash = hash * 31 + ExternalDelta.GetHashCode();
        hash = hash * 31 + KinematicSpeed.GetHashCode();
        hash = hash * 31 + KinematicTangent.GetHashCode();
        hash = hash * 31 + KinematicDirection.GetHashCode();
        hash = hash * 31 + KinematicVelocity.GetHashCode();
        hash = hash * 31 + DynamicVelocity.GetHashCode();
        hash = hash * 31 + RealSpeed.GetHashCode();
        hash = hash * 31 + RealVelocity.GetHashCode();
        hash = hash * 31 + HasJumped.GetHashCode();
        hash = hash * 31 + HasTeleported.GetHashCode();
        hash = hash * 31 + IsGrounded.GetHashCode();
        hash = hash * 31 + WasGrounded.GetHashCode();
        hash = hash * 31 + IsSteppingUp.GetHashCode();
        hash = hash * 31 + WasSteppingUp.GetHashCode();
        hash = hash * 31 + IsSnappingToGround.GetHashCode();
        hash = hash * 31 + WasSnappingToGround.GetHashCode();
        hash = hash * 31 + GroundNormal.GetHashCode();
        hash = hash * 31 + GroundTangent.GetHashCode();
        hash = hash * 31 + GroundPosition.GetHashCode();
        hash = hash * 31 + GroundDistance.GetHashCode();
        hash = hash * 31 + GroundAngle.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCData*)ptr;
        QBoolean.Serialize(&p->HasJumped, serializer);
        QBoolean.Serialize(&p->HasTeleported, serializer);
        QBoolean.Serialize(&p->IsActive, serializer);
        QBoolean.Serialize(&p->IsGrounded, serializer);
        QBoolean.Serialize(&p->IsSnappingToGround, serializer);
        QBoolean.Serialize(&p->IsSteppingUp, serializer);
        QBoolean.Serialize(&p->WasGrounded, serializer);
        QBoolean.Serialize(&p->WasSnappingToGround, serializer);
        QBoolean.Serialize(&p->WasSteppingUp, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        FP.Serialize(&p->GroundAngle, serializer);
        FP.Serialize(&p->GroundDistance, serializer);
        FP.Serialize(&p->KinematicSpeed, serializer);
        FP.Serialize(&p->LookPitch, serializer);
        FP.Serialize(&p->LookYaw, serializer);
        FP.Serialize(&p->MaxGroundAngle, serializer);
        FP.Serialize(&p->MaxHangAngle, serializer);
        FP.Serialize(&p->MaxWallAngle, serializer);
        FP.Serialize(&p->RealSpeed, serializer);
        FPVector3.Serialize(&p->BasePosition, serializer);
        FPVector3.Serialize(&p->DesiredPosition, serializer);
        FPVector3.Serialize(&p->DynamicVelocity, serializer);
        FPVector3.Serialize(&p->ExternalDelta, serializer);
        FPVector3.Serialize(&p->ExternalForce, serializer);
        FPVector3.Serialize(&p->ExternalImpulse, serializer);
        FPVector3.Serialize(&p->Gravity, serializer);
        FPVector3.Serialize(&p->GroundNormal, serializer);
        FPVector3.Serialize(&p->GroundPosition, serializer);
        FPVector3.Serialize(&p->GroundTangent, serializer);
        FPVector3.Serialize(&p->InputDirection, serializer);
        FPVector3.Serialize(&p->JumpImpulse, serializer);
        FPVector3.Serialize(&p->KinematicDirection, serializer);
        FPVector3.Serialize(&p->KinematicTangent, serializer);
        FPVector3.Serialize(&p->KinematicVelocity, serializer);
        FPVector3.Serialize(&p->RealVelocity, serializer);
        FPVector3.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCIgnore {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCIgnoreSource Source;
    [FieldOffset(8)]
    public EntityRef Reference;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 283;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCIgnore*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCModifier {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef Processor;
    [FieldOffset(8)]
    public EntityRef Entity;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15959;
        hash = hash * 31 + Processor.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCModifier*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LayerData {
    public const Int32 SIZE = 152;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(96)]
    [HideInInspector()]
    public FP Time;
    [FieldOffset(80)]
    [HideInInspector()]
    public FP NormalizedTime;
    [FieldOffset(64)]
    [HideInInspector()]
    public FP LastTime;
    [FieldOffset(72)]
    [HideInInspector()]
    public FP Length;
    [FieldOffset(4)]
    [HideInInspector()]
    public Int32 CurrentStateId;
    [FieldOffset(20)]
    [HideInInspector()]
    public QBoolean Freeze;
    [FieldOffset(88)]
    [HideInInspector()]
    public FP Speed;
    [FieldOffset(8)]
    [HideInInspector()]
    public Int32 FromStateId;
    [FieldOffset(56)]
    [HideInInspector()]
    public FP FromStateTime;
    [FieldOffset(40)]
    [HideInInspector()]
    public FP FromStateLastTime;
    [FieldOffset(48)]
    [HideInInspector()]
    public FP FromStateNormalizedTime;
    [FieldOffset(32)]
    [HideInInspector()]
    public FP FromLength;
    [FieldOffset(12)]
    [HideInInspector()]
    public Int32 ToStateId;
    [FieldOffset(128)]
    [HideInInspector()]
    public FP ToStateTime;
    [FieldOffset(112)]
    [HideInInspector()]
    public FP ToStateLastTime;
    [FieldOffset(120)]
    [HideInInspector()]
    public FP ToStateNormalizedTime;
    [FieldOffset(104)]
    [HideInInspector()]
    public FP ToLength;
    [FieldOffset(16)]
    [HideInInspector()]
    public Int32 TransitionIndex;
    [FieldOffset(144)]
    [HideInInspector()]
    public FP TransitionTime;
    [FieldOffset(136)]
    [HideInInspector()]
    public FP TransitionDuration;
    [FieldOffset(0)]
    [HideInInspector()]
    public Int32 AnimatorBlendCount;
    [FieldOffset(24)]
    public QBoolean IgnoreTransitions;
    [FieldOffset(28)]
    [HideInInspector()]
    public QDictionaryPtr<Int32, BlendTreeWeights> BlendTreeWeights;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 16301;
        hash = hash * 31 + Time.GetHashCode();
        hash = hash * 31 + NormalizedTime.GetHashCode();
        hash = hash * 31 + LastTime.GetHashCode();
        hash = hash * 31 + Length.GetHashCode();
        hash = hash * 31 + CurrentStateId.GetHashCode();
        hash = hash * 31 + Freeze.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + FromStateId.GetHashCode();
        hash = hash * 31 + FromStateTime.GetHashCode();
        hash = hash * 31 + FromStateLastTime.GetHashCode();
        hash = hash * 31 + FromStateNormalizedTime.GetHashCode();
        hash = hash * 31 + FromLength.GetHashCode();
        hash = hash * 31 + ToStateId.GetHashCode();
        hash = hash * 31 + ToStateTime.GetHashCode();
        hash = hash * 31 + ToStateLastTime.GetHashCode();
        hash = hash * 31 + ToStateNormalizedTime.GetHashCode();
        hash = hash * 31 + ToLength.GetHashCode();
        hash = hash * 31 + TransitionIndex.GetHashCode();
        hash = hash * 31 + TransitionTime.GetHashCode();
        hash = hash * 31 + TransitionDuration.GetHashCode();
        hash = hash * 31 + AnimatorBlendCount.GetHashCode();
        hash = hash * 31 + IgnoreTransitions.GetHashCode();
        hash = hash * 31 + BlendTreeWeights.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      BlendTreeWeights = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LayerData*)ptr;
        serializer.Stream.Serialize(&p->AnimatorBlendCount);
        serializer.Stream.Serialize(&p->CurrentStateId);
        serializer.Stream.Serialize(&p->FromStateId);
        serializer.Stream.Serialize(&p->ToStateId);
        serializer.Stream.Serialize(&p->TransitionIndex);
        QBoolean.Serialize(&p->Freeze, serializer);
        QBoolean.Serialize(&p->IgnoreTransitions, serializer);
        QDictionary.Serialize(&p->BlendTreeWeights, serializer, Statics.SerializeInt32, Statics.SerializeBlendTreeWeights);
        FP.Serialize(&p->FromLength, serializer);
        FP.Serialize(&p->FromStateLastTime, serializer);
        FP.Serialize(&p->FromStateNormalizedTime, serializer);
        FP.Serialize(&p->FromStateTime, serializer);
        FP.Serialize(&p->LastTime, serializer);
        FP.Serialize(&p->Length, serializer);
        FP.Serialize(&p->NormalizedTime, serializer);
        FP.Serialize(&p->Speed, serializer);
        FP.Serialize(&p->Time, serializer);
        FP.Serialize(&p->ToLength, serializer);
        FP.Serialize(&p->ToStateLastTime, serializer);
        FP.Serialize(&p->ToStateNormalizedTime, serializer);
        FP.Serialize(&p->ToStateTime, serializer);
        FP.Serialize(&p->TransitionDuration, serializer);
        FP.Serialize(&p->TransitionTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 840;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(80)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(96)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(112)]
    public RNGSession RngSession;
    [FieldOffset(128)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(176)]
    public BitSet1024 Systems;
    [FieldOffset(304)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(600)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(608)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 2)]
    private fixed Byte _input_[224];
    [FieldOffset(832)]
    public BitSet2 PlayerLastConnectionState;
    public readonly FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 112, 2); }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet2.Serialize(&p->PlayerLastConnectionState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct AnimatorRuntimeVariable {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.FPVALUE)]
    private FP _FPValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.INTEGERVALUE)]
    private Int32 _IntegerValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.BOOLEANVALUE)]
    private QBoolean _BooleanValue;
    public const Int32 FPVALUE = 1;
    public const Int32 INTEGERVALUE = 2;
    public const Int32 BOOLEANVALUE = 3;
    public readonly Int32 Field {
      get {
        return _field_used_;
      }
    }
    public FP* FPValue {
      get {
        fixed (FP* p = &_FPValue) {
          if (_field_used_ != FPVALUE) {
            Native.Utils.Clear(p, 8);
            _field_used_ = FPVALUE;
          }
          return p;
        }
      }
    }
    public Int32* IntegerValue {
      get {
        fixed (Int32* p = &_IntegerValue) {
          if (_field_used_ != INTEGERVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = INTEGERVALUE;
          }
          return p;
        }
      }
    }
    public QBoolean* BooleanValue {
      get {
        fixed (QBoolean* p = &_BooleanValue) {
          if (_field_used_ != BOOLEANVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = BOOLEANVALUE;
          }
          return p;
        }
      }
    }
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 19843;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _FPValue.GetHashCode();
        hash = hash * 31 + _IntegerValue.GetHashCode();
        hash = hash * 31 + _BooleanValue.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimatorRuntimeVariable*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.AnimatorRuntimeVariable.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == BOOLEANVALUE) {
          QBoolean.Serialize(&p->_BooleanValue, serializer);
        }
        if (p->_field_used_ == FPVALUE) {
          FP.Serialize(&p->_FPValue, serializer);
        }
        if (p->_field_used_ == INTEGERVALUE) {
          serializer.Stream.Serialize(&p->_IntegerValue);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AnimatorComponent : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [HideInInspector()]
    public EntityRef Self;
    [FieldOffset(8)]
    public AssetRef<AnimatorGraph> AnimatorGraph;
    [FieldOffset(4)]
    [HideInInspector()]
    public QListPtr<LayerData> Layers;
    [FieldOffset(0)]
    [HideInInspector()]
    public QListPtr<AnimatorRuntimeVariable> AnimatorVariables;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18413;
        hash = hash * 31 + Self.GetHashCode();
        hash = hash * 31 + AnimatorGraph.GetHashCode();
        hash = hash * 31 + Layers.GetHashCode();
        hash = hash * 31 + AnimatorVariables.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Layers = default;
      AnimatorVariables = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.AnimatorComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimatorComponent*)ptr;
        QList.Serialize(&p->AnimatorVariables, serializer, Statics.SerializeAnimatorRuntimeVariable);
        QList.Serialize(&p->Layers, serializer, Statics.SerializeLayerData);
        AssetRef.Serialize(&p->AnimatorGraph, serializer);
        EntityRef.Serialize(&p->Self, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CurrentAction : Quantum.IComponent {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public Int32 ActionNumber;
    [FieldOffset(12)]
    public Int32 ActionIndex;
    [FieldOffset(40)]
    public FPVector2 Direction;
    [FieldOffset(104)]
    public FPVector3 PlayerPosition;
    [FieldOffset(80)]
    public FPVector3 EnemyPosition;
    [FieldOffset(1)]
    public Byte AttackIndex;
    [FieldOffset(20)]
    public Int32 StartTick;
    [FieldOffset(10)]
    public UInt16 StartUpFrames;
    [FieldOffset(2)]
    public UInt16 ActiveFrames;
    [FieldOffset(8)]
    public UInt16 RecoveryFrames;
    [FieldOffset(4)]
    public UInt16 CancelableFrames;
    [FieldOffset(0)]
    public Byte ActionPhase;
    [FieldOffset(6)]
    public UInt16 Damage;
    [FieldOffset(56)]
    public FPVector3 DashEndPos;
    [FieldOffset(32)]
    public FP PrecentageOfDodgeCompletable;
    [FieldOffset(24)]
    public QBoolean DamageApplied;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 109;
        hash = hash * 31 + ActionNumber.GetHashCode();
        hash = hash * 31 + ActionIndex.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + PlayerPosition.GetHashCode();
        hash = hash * 31 + EnemyPosition.GetHashCode();
        hash = hash * 31 + AttackIndex.GetHashCode();
        hash = hash * 31 + StartTick.GetHashCode();
        hash = hash * 31 + StartUpFrames.GetHashCode();
        hash = hash * 31 + ActiveFrames.GetHashCode();
        hash = hash * 31 + RecoveryFrames.GetHashCode();
        hash = hash * 31 + CancelableFrames.GetHashCode();
        hash = hash * 31 + ActionPhase.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + DashEndPos.GetHashCode();
        hash = hash * 31 + PrecentageOfDodgeCompletable.GetHashCode();
        hash = hash * 31 + DamageApplied.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CurrentAction*)ptr;
        serializer.Stream.Serialize(&p->ActionPhase);
        serializer.Stream.Serialize(&p->AttackIndex);
        serializer.Stream.Serialize(&p->ActiveFrames);
        serializer.Stream.Serialize(&p->CancelableFrames);
        serializer.Stream.Serialize(&p->Damage);
        serializer.Stream.Serialize(&p->RecoveryFrames);
        serializer.Stream.Serialize(&p->StartUpFrames);
        serializer.Stream.Serialize(&p->ActionIndex);
        serializer.Stream.Serialize(&p->ActionNumber);
        serializer.Stream.Serialize(&p->StartTick);
        QBoolean.Serialize(&p->DamageApplied, serializer);
        FP.Serialize(&p->PrecentageOfDodgeCompletable, serializer);
        FPVector2.Serialize(&p->Direction, serializer);
        FPVector3.Serialize(&p->DashEndPos, serializer);
        FPVector3.Serialize(&p->EnemyPosition, serializer);
        FPVector3.Serialize(&p->PlayerPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CurrentGameStateFlags : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 Flags;
    [FieldOffset(8)]
    public FPVector2 InputDirection;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 4663;
        hash = hash * 31 + Flags.GetHashCode();
        hash = hash * 31 + InputDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CurrentGameStateFlags*)ptr;
        serializer.Stream.Serialize(&p->Flags);
        FPVector2.Serialize(&p->InputDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Damageable : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 2;
    [FieldOffset(2)]
    private fixed Byte _alignment_padding_[2];
    [FieldOffset(0)]
    public UInt16 Health;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21187;
        hash = hash * 31 + Health.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Damageable*)ptr;
        serializer.Stream.Serialize(&p->Health);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GlobalHitstop : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public Int32 FramesLeft;
    [FieldOffset(0)]
    public Int32 DelayLeft;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 18133;
        hash = hash * 31 + FramesLeft.GetHashCode();
        hash = hash * 31 + DelayLeft.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GlobalHitstop*)ptr;
        serializer.Stream.Serialize(&p->DelayLeft);
        serializer.Stream.Serialize(&p->FramesLeft);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GlobalTag : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6791;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GlobalTag*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Hitstop : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public Int32 FramesLeft;
    [FieldOffset(8)]
    public EntityRef Source;
    [FieldOffset(0)]
    public Byte Flags;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 7993;
        hash = hash * 31 + FramesLeft.GetHashCode();
        hash = hash * 31 + Source.GetHashCode();
        hash = hash * 31 + Flags.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Hitstop*)ptr;
        serializer.Stream.Serialize(&p->Flags);
        serializer.Stream.Serialize(&p->FramesLeft);
        EntityRef.Serialize(&p->Source, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HitstopStarted : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 15859;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HitstopStarted*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InputBuffer : Quantum.IComponent {
    public const Int32 SIZE = 408;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(248)]
    public FPVector2 LastDirection0;
    [FieldOffset(84)]
    public QBoolean Jump0;
    [FieldOffset(4)]
    public QBoolean Dodge0;
    [FieldOffset(124)]
    public QBoolean LightAttack0;
    [FieldOffset(44)]
    public QBoolean HeavyAttack0;
    [FieldOffset(164)]
    public QBoolean Parry0;
    [FieldOffset(204)]
    public QBoolean Special0;
    [FieldOffset(264)]
    public FPVector2 LastDirection1;
    [FieldOffset(88)]
    public QBoolean Jump1;
    [FieldOffset(8)]
    public QBoolean Dodge1;
    [FieldOffset(128)]
    public QBoolean LightAttack1;
    [FieldOffset(48)]
    public QBoolean HeavyAttack1;
    [FieldOffset(168)]
    public QBoolean Parry1;
    [FieldOffset(208)]
    public QBoolean Special1;
    [FieldOffset(280)]
    public FPVector2 LastDirection2;
    [FieldOffset(92)]
    public QBoolean Jump2;
    [FieldOffset(12)]
    public QBoolean Dodge2;
    [FieldOffset(132)]
    public QBoolean LightAttack2;
    [FieldOffset(52)]
    public QBoolean HeavyAttack2;
    [FieldOffset(172)]
    public QBoolean Parry2;
    [FieldOffset(212)]
    public QBoolean Special2;
    [FieldOffset(296)]
    public FPVector2 LastDirection3;
    [FieldOffset(96)]
    public QBoolean Jump3;
    [FieldOffset(16)]
    public QBoolean Dodge3;
    [FieldOffset(136)]
    public QBoolean LightAttack3;
    [FieldOffset(56)]
    public QBoolean HeavyAttack3;
    [FieldOffset(176)]
    public QBoolean Parry3;
    [FieldOffset(216)]
    public QBoolean Special3;
    [FieldOffset(312)]
    public FPVector2 LastDirection4;
    [FieldOffset(100)]
    public QBoolean Jump4;
    [FieldOffset(20)]
    public QBoolean Dodge4;
    [FieldOffset(140)]
    public QBoolean LightAttack4;
    [FieldOffset(60)]
    public QBoolean HeavyAttack4;
    [FieldOffset(180)]
    public QBoolean Parry4;
    [FieldOffset(220)]
    public QBoolean Special4;
    [FieldOffset(328)]
    public FPVector2 LastDirection5;
    [FieldOffset(104)]
    public QBoolean Jump5;
    [FieldOffset(24)]
    public QBoolean Dodge5;
    [FieldOffset(144)]
    public QBoolean LightAttack5;
    [FieldOffset(64)]
    public QBoolean HeavyAttack5;
    [FieldOffset(184)]
    public QBoolean Parry5;
    [FieldOffset(224)]
    public QBoolean Special5;
    [FieldOffset(344)]
    public FPVector2 LastDirection6;
    [FieldOffset(108)]
    public QBoolean Jump6;
    [FieldOffset(28)]
    public QBoolean Dodge6;
    [FieldOffset(148)]
    public QBoolean LightAttack6;
    [FieldOffset(68)]
    public QBoolean HeavyAttack6;
    [FieldOffset(188)]
    public QBoolean Parry6;
    [FieldOffset(228)]
    public QBoolean Special6;
    [FieldOffset(360)]
    public FPVector2 LastDirection7;
    [FieldOffset(112)]
    public QBoolean Jump7;
    [FieldOffset(32)]
    public QBoolean Dodge7;
    [FieldOffset(152)]
    public QBoolean LightAttack7;
    [FieldOffset(72)]
    public QBoolean HeavyAttack7;
    [FieldOffset(192)]
    public QBoolean Parry7;
    [FieldOffset(232)]
    public QBoolean Special7;
    [FieldOffset(376)]
    public FPVector2 LastDirection8;
    [FieldOffset(116)]
    public QBoolean Jump8;
    [FieldOffset(36)]
    public QBoolean Dodge8;
    [FieldOffset(156)]
    public QBoolean LightAttack8;
    [FieldOffset(76)]
    public QBoolean HeavyAttack8;
    [FieldOffset(196)]
    public QBoolean Parry8;
    [FieldOffset(236)]
    public QBoolean Special8;
    [FieldOffset(392)]
    public FPVector2 LastDirection9;
    [FieldOffset(120)]
    public QBoolean Jump9;
    [FieldOffset(40)]
    public QBoolean Dodge9;
    [FieldOffset(160)]
    public QBoolean LightAttack9;
    [FieldOffset(80)]
    public QBoolean HeavyAttack9;
    [FieldOffset(200)]
    public QBoolean Parry9;
    [FieldOffset(240)]
    public QBoolean Special9;
    [FieldOffset(0)]
    public Byte Count;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3637;
        hash = hash * 31 + LastDirection0.GetHashCode();
        hash = hash * 31 + Jump0.GetHashCode();
        hash = hash * 31 + Dodge0.GetHashCode();
        hash = hash * 31 + LightAttack0.GetHashCode();
        hash = hash * 31 + HeavyAttack0.GetHashCode();
        hash = hash * 31 + Parry0.GetHashCode();
        hash = hash * 31 + Special0.GetHashCode();
        hash = hash * 31 + LastDirection1.GetHashCode();
        hash = hash * 31 + Jump1.GetHashCode();
        hash = hash * 31 + Dodge1.GetHashCode();
        hash = hash * 31 + LightAttack1.GetHashCode();
        hash = hash * 31 + HeavyAttack1.GetHashCode();
        hash = hash * 31 + Parry1.GetHashCode();
        hash = hash * 31 + Special1.GetHashCode();
        hash = hash * 31 + LastDirection2.GetHashCode();
        hash = hash * 31 + Jump2.GetHashCode();
        hash = hash * 31 + Dodge2.GetHashCode();
        hash = hash * 31 + LightAttack2.GetHashCode();
        hash = hash * 31 + HeavyAttack2.GetHashCode();
        hash = hash * 31 + Parry2.GetHashCode();
        hash = hash * 31 + Special2.GetHashCode();
        hash = hash * 31 + LastDirection3.GetHashCode();
        hash = hash * 31 + Jump3.GetHashCode();
        hash = hash * 31 + Dodge3.GetHashCode();
        hash = hash * 31 + LightAttack3.GetHashCode();
        hash = hash * 31 + HeavyAttack3.GetHashCode();
        hash = hash * 31 + Parry3.GetHashCode();
        hash = hash * 31 + Special3.GetHashCode();
        hash = hash * 31 + LastDirection4.GetHashCode();
        hash = hash * 31 + Jump4.GetHashCode();
        hash = hash * 31 + Dodge4.GetHashCode();
        hash = hash * 31 + LightAttack4.GetHashCode();
        hash = hash * 31 + HeavyAttack4.GetHashCode();
        hash = hash * 31 + Parry4.GetHashCode();
        hash = hash * 31 + Special4.GetHashCode();
        hash = hash * 31 + LastDirection5.GetHashCode();
        hash = hash * 31 + Jump5.GetHashCode();
        hash = hash * 31 + Dodge5.GetHashCode();
        hash = hash * 31 + LightAttack5.GetHashCode();
        hash = hash * 31 + HeavyAttack5.GetHashCode();
        hash = hash * 31 + Parry5.GetHashCode();
        hash = hash * 31 + Special5.GetHashCode();
        hash = hash * 31 + LastDirection6.GetHashCode();
        hash = hash * 31 + Jump6.GetHashCode();
        hash = hash * 31 + Dodge6.GetHashCode();
        hash = hash * 31 + LightAttack6.GetHashCode();
        hash = hash * 31 + HeavyAttack6.GetHashCode();
        hash = hash * 31 + Parry6.GetHashCode();
        hash = hash * 31 + Special6.GetHashCode();
        hash = hash * 31 + LastDirection7.GetHashCode();
        hash = hash * 31 + Jump7.GetHashCode();
        hash = hash * 31 + Dodge7.GetHashCode();
        hash = hash * 31 + LightAttack7.GetHashCode();
        hash = hash * 31 + HeavyAttack7.GetHashCode();
        hash = hash * 31 + Parry7.GetHashCode();
        hash = hash * 31 + Special7.GetHashCode();
        hash = hash * 31 + LastDirection8.GetHashCode();
        hash = hash * 31 + Jump8.GetHashCode();
        hash = hash * 31 + Dodge8.GetHashCode();
        hash = hash * 31 + LightAttack8.GetHashCode();
        hash = hash * 31 + HeavyAttack8.GetHashCode();
        hash = hash * 31 + Parry8.GetHashCode();
        hash = hash * 31 + Special8.GetHashCode();
        hash = hash * 31 + LastDirection9.GetHashCode();
        hash = hash * 31 + Jump9.GetHashCode();
        hash = hash * 31 + Dodge9.GetHashCode();
        hash = hash * 31 + LightAttack9.GetHashCode();
        hash = hash * 31 + HeavyAttack9.GetHashCode();
        hash = hash * 31 + Parry9.GetHashCode();
        hash = hash * 31 + Special9.GetHashCode();
        hash = hash * 31 + Count.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InputBuffer*)ptr;
        serializer.Stream.Serialize(&p->Count);
        QBoolean.Serialize(&p->Dodge0, serializer);
        QBoolean.Serialize(&p->Dodge1, serializer);
        QBoolean.Serialize(&p->Dodge2, serializer);
        QBoolean.Serialize(&p->Dodge3, serializer);
        QBoolean.Serialize(&p->Dodge4, serializer);
        QBoolean.Serialize(&p->Dodge5, serializer);
        QBoolean.Serialize(&p->Dodge6, serializer);
        QBoolean.Serialize(&p->Dodge7, serializer);
        QBoolean.Serialize(&p->Dodge8, serializer);
        QBoolean.Serialize(&p->Dodge9, serializer);
        QBoolean.Serialize(&p->HeavyAttack0, serializer);
        QBoolean.Serialize(&p->HeavyAttack1, serializer);
        QBoolean.Serialize(&p->HeavyAttack2, serializer);
        QBoolean.Serialize(&p->HeavyAttack3, serializer);
        QBoolean.Serialize(&p->HeavyAttack4, serializer);
        QBoolean.Serialize(&p->HeavyAttack5, serializer);
        QBoolean.Serialize(&p->HeavyAttack6, serializer);
        QBoolean.Serialize(&p->HeavyAttack7, serializer);
        QBoolean.Serialize(&p->HeavyAttack8, serializer);
        QBoolean.Serialize(&p->HeavyAttack9, serializer);
        QBoolean.Serialize(&p->Jump0, serializer);
        QBoolean.Serialize(&p->Jump1, serializer);
        QBoolean.Serialize(&p->Jump2, serializer);
        QBoolean.Serialize(&p->Jump3, serializer);
        QBoolean.Serialize(&p->Jump4, serializer);
        QBoolean.Serialize(&p->Jump5, serializer);
        QBoolean.Serialize(&p->Jump6, serializer);
        QBoolean.Serialize(&p->Jump7, serializer);
        QBoolean.Serialize(&p->Jump8, serializer);
        QBoolean.Serialize(&p->Jump9, serializer);
        QBoolean.Serialize(&p->LightAttack0, serializer);
        QBoolean.Serialize(&p->LightAttack1, serializer);
        QBoolean.Serialize(&p->LightAttack2, serializer);
        QBoolean.Serialize(&p->LightAttack3, serializer);
        QBoolean.Serialize(&p->LightAttack4, serializer);
        QBoolean.Serialize(&p->LightAttack5, serializer);
        QBoolean.Serialize(&p->LightAttack6, serializer);
        QBoolean.Serialize(&p->LightAttack7, serializer);
        QBoolean.Serialize(&p->LightAttack8, serializer);
        QBoolean.Serialize(&p->LightAttack9, serializer);
        QBoolean.Serialize(&p->Parry0, serializer);
        QBoolean.Serialize(&p->Parry1, serializer);
        QBoolean.Serialize(&p->Parry2, serializer);
        QBoolean.Serialize(&p->Parry3, serializer);
        QBoolean.Serialize(&p->Parry4, serializer);
        QBoolean.Serialize(&p->Parry5, serializer);
        QBoolean.Serialize(&p->Parry6, serializer);
        QBoolean.Serialize(&p->Parry7, serializer);
        QBoolean.Serialize(&p->Parry8, serializer);
        QBoolean.Serialize(&p->Parry9, serializer);
        QBoolean.Serialize(&p->Special0, serializer);
        QBoolean.Serialize(&p->Special1, serializer);
        QBoolean.Serialize(&p->Special2, serializer);
        QBoolean.Serialize(&p->Special3, serializer);
        QBoolean.Serialize(&p->Special4, serializer);
        QBoolean.Serialize(&p->Special5, serializer);
        QBoolean.Serialize(&p->Special6, serializer);
        QBoolean.Serialize(&p->Special7, serializer);
        QBoolean.Serialize(&p->Special8, serializer);
        QBoolean.Serialize(&p->Special9, serializer);
        FPVector2.Serialize(&p->LastDirection0, serializer);
        FPVector2.Serialize(&p->LastDirection1, serializer);
        FPVector2.Serialize(&p->LastDirection2, serializer);
        FPVector2.Serialize(&p->LastDirection3, serializer);
        FPVector2.Serialize(&p->LastDirection4, serializer);
        FPVector2.Serialize(&p->LastDirection5, serializer);
        FPVector2.Serialize(&p->LastDirection6, serializer);
        FPVector2.Serialize(&p->LastDirection7, serializer);
        FPVector2.Serialize(&p->LastDirection8, serializer);
        FPVector2.Serialize(&p->LastDirection9, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCC : Quantum.IComponent {
    public const Int32 SIZE = 560;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<KCCSettings> Settings;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsInitialized;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef Entity;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public KCCData Data;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QHashSetPtr<KCCIgnore> Ignores;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCModifier> Modifiers;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCCollision> Collisions;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 659;
        hash = hash * 31 + Settings.GetHashCode();
        hash = hash * 31 + IsInitialized.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Data.GetHashCode();
        hash = hash * 31 + Ignores.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        hash = hash * 31 + Collisions.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Ignores = default;
      Modifiers = default;
      Collisions = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.KCC*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCC*)ptr;
        QBoolean.Serialize(&p->IsInitialized, serializer);
        QHashSet.Serialize(&p->Ignores, serializer, Statics.SerializeKCCIgnore);
        QList.Serialize(&p->Collisions, serializer, Statics.SerializeKCCCollision);
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeKCCModifier);
        AssetRef.Serialize(&p->Settings, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
        Quantum.KCCData.Serialize(&p->Data, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCProcessorLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<KCCProcessor> Processor;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 13411;
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCProcessorLink*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MeleeHitbox : Quantum.IComponent {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public EntityRef Owner;
    [FieldOffset(32)]
    public FP Radius;
    [FieldOffset(24)]
    public FP Height;
    [FieldOffset(40)]
    public FPVector2 HitDirection;
    [FieldOffset(56)]
    public FPVector3 BasePoint;
    [FieldOffset(80)]
    public FPVector3 EndPoint;
    [FieldOffset(2)]
    public UInt16 Lifetime;
    [FieldOffset(4)]
    public Int32 SpawnFrame;
    [FieldOffset(0)]
    public UInt16 Damage;
    [FieldOffset(8)]
    public QBoolean DamageApplied;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 3671;
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + Radius.GetHashCode();
        hash = hash * 31 + Height.GetHashCode();
        hash = hash * 31 + HitDirection.GetHashCode();
        hash = hash * 31 + BasePoint.GetHashCode();
        hash = hash * 31 + EndPoint.GetHashCode();
        hash = hash * 31 + Lifetime.GetHashCode();
        hash = hash * 31 + SpawnFrame.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + DamageApplied.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MeleeHitbox*)ptr;
        serializer.Stream.Serialize(&p->Damage);
        serializer.Stream.Serialize(&p->Lifetime);
        serializer.Stream.Serialize(&p->SpawnFrame);
        QBoolean.Serialize(&p->DamageApplied, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        FP.Serialize(&p->Height, serializer);
        FP.Serialize(&p->Radius, serializer);
        FPVector2.Serialize(&p->HitDirection, serializer);
        FPVector3.Serialize(&p->BasePoint, serializer);
        FPVector3.Serialize(&p->EndPoint, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ParryComponent : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean HeavyParry;
    [FieldOffset(4)]
    public QBoolean HeldBlock;
    [FieldOffset(8)]
    public FPVector2 Direction;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 6067;
        hash = hash * 31 + HeavyParry.GetHashCode();
        hash = hash * 31 + HeldBlock.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ParryComponent*)ptr;
        QBoolean.Serialize(&p->HeavyParry, serializer);
        QBoolean.Serialize(&p->HeldBlock, serializer);
        FPVector2.Serialize(&p->Direction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public PlayerRef Player;
    [FieldOffset(8)]
    public EntityRef Entity;
    public override readonly Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->Player, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
    }
  }
  public unsafe partial interface ISignalOnAnimatorStateEnter : ISignal {
    void OnAnimatorStateEnter(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time);
  }
  public unsafe partial interface ISignalOnAnimatorStateUpdate : ISignal {
    void OnAnimatorStateUpdate(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time, AnimatorStateType stateType);
  }
  public unsafe partial interface ISignalOnAnimatorStateExit : ISignal {
    void OnAnimatorStateExit(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time);
  }
  public unsafe partial interface ISignalOnAnimatorRootMotion3D : ISignal {
    void OnAnimatorRootMotion3D(Frame f, EntityRef entity, AnimatorFrame deltaFrame, AnimatorFrame currentFrame);
  }
  public unsafe partial interface ISignalOnAnimatorRootMotion2D : ISignal {
    void OnAnimatorRootMotion2D(Frame f, EntityRef entity, AnimatorFrame deltaFrame, AnimatorFrame currentFrame);
  }
  public static unsafe partial class Constants {
    public const Int32 PLAYER_COUNT = 2;
  }
  public unsafe partial class Frame {
    private ISignalOnAnimatorStateEnter[] _ISignalOnAnimatorStateEnterSystems;
    private ISignalOnAnimatorStateUpdate[] _ISignalOnAnimatorStateUpdateSystems;
    private ISignalOnAnimatorStateExit[] _ISignalOnAnimatorStateExitSystems;
    private ISignalOnAnimatorRootMotion3D[] _ISignalOnAnimatorRootMotion3DSystems;
    private ISignalOnAnimatorRootMotion2D[] _ISignalOnAnimatorRootMotion2DSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnAnimatorStateEnterSystems = BuildSignalsArray<ISignalOnAnimatorStateEnter>();
      _ISignalOnAnimatorStateUpdateSystems = BuildSignalsArray<ISignalOnAnimatorStateUpdate>();
      _ISignalOnAnimatorStateExitSystems = BuildSignalsArray<ISignalOnAnimatorStateExit>();
      _ISignalOnAnimatorRootMotion3DSystems = BuildSignalsArray<ISignalOnAnimatorRootMotion3D>();
      _ISignalOnAnimatorRootMotion2DSystems = BuildSignalsArray<ISignalOnAnimatorRootMotion2D>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AnimatorComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AnimatorComponent>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.CurrentAction>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CurrentAction>();
      BuildSignalsArrayOnComponentAdded<Quantum.CurrentGameStateFlags>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CurrentGameStateFlags>();
      BuildSignalsArrayOnComponentAdded<Quantum.Damageable>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Damageable>();
      BuildSignalsArrayOnComponentAdded<Quantum.GlobalHitstop>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GlobalHitstop>();
      BuildSignalsArrayOnComponentAdded<Quantum.GlobalTag>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GlobalTag>();
      BuildSignalsArrayOnComponentAdded<Quantum.Hitstop>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Hitstop>();
      BuildSignalsArrayOnComponentAdded<Quantum.HitstopStarted>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HitstopStarted>();
      BuildSignalsArrayOnComponentAdded<Quantum.InputBuffer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InputBuffer>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCC>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCC>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.MeleeHitbox>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MeleeHitbox>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.ParryComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ParryComponent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->LeftStickDirection = input.LeftStickDirection;
      i->Jump = i->Jump.Update(this.Number, input.Jump);
      i->JumpHeld = input.JumpHeld;
      i->Dodge = i->Dodge.Update(this.Number, input.Dodge);
      i->DodgeHeld = input.DodgeHeld;
      i->LightAttack = i->LightAttack.Update(this.Number, input.LightAttack);
      i->LightAttackHeld = input.LightAttackHeld;
      i->HeavyAttack = i->HeavyAttack.Update(this.Number, input.HeavyAttack);
      i->HeavyAttackHeld = input.HeavyAttackHeld;
      i->Parry = i->Parry.Update(this.Number, input.Parry);
      i->ParryHeld = input.ParryHeld;
      i->Special = i->Special.Update(this.Number, input.Special);
      i->SpecialHeld = input.SpecialHeld;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnAnimatorStateEnter(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time) {
        var array = _f._ISignalOnAnimatorStateEnterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateEnter(_f, entity, animator, graph, layer, state, time);
          }
        }
      }
      public void OnAnimatorStateUpdate(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time, AnimatorStateType stateType) {
        var array = _f._ISignalOnAnimatorStateUpdateSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateUpdate(_f, entity, animator, graph, layer, state, time, stateType);
          }
        }
      }
      public void OnAnimatorStateExit(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, LayerData* layer, Addons.Animator.AnimatorState state, FP time) {
        var array = _f._ISignalOnAnimatorStateExitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateExit(_f, entity, animator, graph, layer, state, time);
          }
        }
      }
      public void OnAnimatorRootMotion3D(EntityRef entity, AnimatorFrame deltaFrame, AnimatorFrame currentFrame) {
        var array = _f._ISignalOnAnimatorRootMotion3DSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorRootMotion3D(_f, entity, deltaFrame, currentFrame);
          }
        }
      }
      public void OnAnimatorRootMotion2D(EntityRef entity, AnimatorFrame deltaFrame, AnimatorFrame currentFrame) {
        var array = _f._ISignalOnAnimatorRootMotion2DSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorRootMotion2D(_f, entity, deltaFrame, currentFrame);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAnimatorRuntimeVariable;
    public static FrameSerializer.Delegate SerializeLayerData;
    public static FrameSerializer.Delegate SerializeFP;
    public static FrameSerializer.Delegate SerializeKCCCollision;
    public static FrameSerializer.Delegate SerializeKCCIgnore;
    public static FrameSerializer.Delegate SerializeKCCModifier;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeBlendTreeWeights;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeAnimatorRuntimeVariable = Quantum.AnimatorRuntimeVariable.Serialize;
      SerializeLayerData = Quantum.LayerData.Serialize;
      SerializeFP = FP.Serialize;
      SerializeKCCCollision = Quantum.KCCCollision.Serialize;
      SerializeKCCIgnore = Quantum.KCCIgnore.Serialize;
      SerializeKCCModifier = Quantum.KCCModifier.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeBlendTreeWeights = Quantum.BlendTreeWeights.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.AnimatorComponent), Quantum.AnimatorComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.AnimatorRuntimeVariable), Quantum.AnimatorRuntimeVariable.SIZE);
      typeRegistry.Register(typeof(Quantum.AnimatorStateType), 1);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2), Quantum.BitSet2.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BlendTreeWeights), Quantum.BlendTreeWeights.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CurrentAction), Quantum.CurrentAction.SIZE);
      typeRegistry.Register(typeof(Quantum.CurrentGameStateFlags), Quantum.CurrentGameStateFlags.SIZE);
      typeRegistry.Register(typeof(Quantum.Damageable), Quantum.Damageable.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.EKCCCollisionSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCIgnoreSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCProcessorSource), 1);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GlobalHitstop), Quantum.GlobalHitstop.SIZE);
      typeRegistry.Register(typeof(Quantum.GlobalTag), Quantum.GlobalTag.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Hitstop), Quantum.Hitstop.SIZE);
      typeRegistry.Register(typeof(Quantum.HitstopStarted), Quantum.HitstopStarted.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputBuffer), Quantum.InputBuffer.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(InputDirection), InputDirection.SIZE);
      typeRegistry.Register(typeof(InputDirectionMagnitude), InputDirectionMagnitude.SIZE);
      typeRegistry.Register(typeof(InputPitchYaw), InputPitchYaw.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KCC), Quantum.KCC.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCCollision), Quantum.KCCCollision.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCData), Quantum.KCCData.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCIgnore), Quantum.KCCIgnore.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCModifier), Quantum.KCCModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCProcessorLink), Quantum.KCCProcessorLink.SIZE);
      typeRegistry.Register(typeof(Quantum.LayerData), Quantum.LayerData.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.MeleeHitbox), Quantum.MeleeHitbox.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(Quantum.ParryComponent), Quantum.ParryComponent.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 14)
        .AddBuiltInComponents()
        .Add<Quantum.AnimatorComponent>(Quantum.AnimatorComponent.Serialize, null, Quantum.AnimatorComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.CurrentAction>(Quantum.CurrentAction.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CurrentGameStateFlags>(Quantum.CurrentGameStateFlags.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Damageable>(Quantum.Damageable.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.GlobalHitstop>(Quantum.GlobalHitstop.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.GlobalTag>(Quantum.GlobalTag.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Hitstop>(Quantum.Hitstop.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.HitstopStarted>(Quantum.HitstopStarted.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InputBuffer>(Quantum.InputBuffer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KCC>(Quantum.KCC.Serialize, null, Quantum.KCC.OnRemoved, ComponentFlags.None)
        .Add<Quantum.KCCProcessorLink>(Quantum.KCCProcessorLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MeleeHitbox>(Quantum.MeleeHitbox.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ParryComponent>(Quantum.ParryComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AnimatorStateType>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCCollisionSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCIgnoreSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCProcessorSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
